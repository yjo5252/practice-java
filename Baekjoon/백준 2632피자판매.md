## 2632 피자판매 


1. 문제 <br>
[문제 링크](https://www.acmicpc.net/problem/2632)
```
고객이 두 종류의 피자 A와 B를 취급하는 피자가게에서 피자를 주문하고자 한다. 
<그림 1>과 같이 각 종류의 피자는 다양한 크기의 여러 개의 피자조각으로 나누어져 있다. 
각 조각에 쓰여진 숫자는 피자조각의 크기를 나타낸다.

고객이 원하는 피자의 크기를 이야기하면, 피자가게에서는 한 종류의 피자를 2 조각 이상 판매할 때는 반드시 연속된 조각들을 잘라서 판매한다. 
이때 판매한 피자조각의 크기 합이 주문한 크기가 되어야 한다. 판매한 피자조각은 모두 A종류이거나, 모두 B종류이거나, 또는 A와 B 종류가 혼합될 수 있다. 
예를 들어서, <그림 1> 과 같이 잘라진 피자가 있을 때, 손님이 전체 크기가 7 인 피자를 주문하면, 피자 가게에서는 <그림2>와 같이 5 가지 방법으로 피자를 판매할 수 있다.

피자가게에서 손님이 원하는 크기의 피자를 판매하는 모든 방법의 가지 수를 계산하는 프로그램을 작성하시오
```

```
첫 번째 줄에는 손님이 구매하고자 하는 피자크기를 나타내는 2,000,000 이하의 자연수가 주어진다. 
두 번째 줄에는 A, B 피자의 피자조각의 개수를 나타내 는 정수 m, n 이 차례로 주어진다 (3 ≤ m, n ≤ 1000). 
세 번째 줄부터 차례로 m 개의 줄에는 피자 A의 미리 잘라진 피자조각의 크기를 나타내는 정수가 주어진다. 
그 다음 n 개의 줄에는 차례로 피자B의 미리 잘라진 피자조각의 크기를 나타내는 정수가 주어진다. 
각 종류의 피자조각의 크기는 시계방향으로 차례로 주어지며, 각 피자 조각의 크기는 1000 이하의 자연수이다.
```
```
예제 입력
7
5 3
2
2
1
7
2
6
8
3

예제 출력 
5
```
2. 풀이방법
* 이분탐색 & 누적 합

3. Java문법 /자료구조
4. 코드
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner; 

public class Main{
	static int target; 
	static int m, n;
	static int[] A, B;
	static boolean[] check;
	static ArrayList<Integer> AList = new ArrayList<>();
	static ArrayList<Integer> BList = new ArrayList<>();
	static int ans=0;
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		target = sc.nextInt();
		m = sc.nextInt();
		n = sc.nextInt();
		
		A = new int[m]; 
		B = new int[n];
		
		for(int i=0; i<m; i++) {
			A[i] = sc.nextInt();
		}
		
		for(int i=0; i<n; i++) {
			B[i] = sc.nextInt();
		}
		
		// A 피자에 대한 부분수열의 합 생성
		for(int i=0; i<m; i++) {
			check = new boolean[m]; 
			check[i] = true;
			getSum(A[i], i, i+1, check, A, AList);
		}
		
		// B 피자에 대한 부분수열의 합 생성 
		for(int i=0; i<n; i++) {
			check = new boolean[n];
			check[i] = true;
			getSum(B[i], i, i+1, check, B, BList);
		}
		
		AList.add(0);
		BList.add(0);
		
		// A리스트, B리스트 정렬
		Collections.sort(AList);
		Collections.sort(BList);
		
		// A 리스트의 왼쪽 인덱스부터, B 리스트의 오른쪽 인덱스부터 
		int leftIdx = 0; 
		int rightIdx = BList.size()-1;
		
		while(leftIdx < AList.size() && rightIdx >= 0) {
			int lv = AList.get(leftIdx);
			int rv = BList.get(rightIdx);
			
			if(lv+rv == target) {
				int lc = 0; 
				int rc = 0;
				while(leftIdx < AList.size() && AList.get(leftIdx) == lv) {
					lc++;
					leftIdx++;
				}
				while(rightIdx >= 0 && BList.get(rightIdx) ==rv) {
					rc++;
					rightIdx--;
				}
				ans += lc*rc;
			}
			if(lv+rv > target) rightIdx--;
			if(lv+rv < target) leftIdx++;
		}
		System.out.println(ans);
	}
	
	// 부분수열의 합 함수
	// 1. 연속된 조각들만 판매한다는 조건
	// 2. 원판은 마지막 배열 조각이 첫째 배열조각과 연결된다 (순환큐를 구현한다) 
	private static void getSum(int sum, int startIdx, int idx, boolean[] check, int[] arr, ArrayList<Integer> list) {
		if(idx == arr.length) { // 배열의 마지막 인덱스인 경우, idx를 0으로 세팅한다. 
			idx = 0; 
		}
		list.add(sum); // 순간의 합을 바로 리스트에 추가한다. 
		// 아직 안담은 피자조각을 판매한다 && 순열의 합이 이미 타겟을 넘어서면 계산하지 않음 && 마지막 인덱스 값을 게속 저장하지 않음
		if(check[idx] == false && sum <= target && idx != startIdx-1) {
			check[idx] = true;
			getSum(sum+arr[idx], startIdx, idx+1, check, arr, list);
		}else {
			return;
		}
	}
}


```


